## 0. 전체 큰 분류

연습장 문제를 크게 3축으로 나누면 좋아:

1. **읽기/이해형**: 코드를 읽고 의미 파악, 출력 예측
2. **판단/비교/디버깅형**: 옳고 그름 판단, 버그 찾기, 반례 찾기
3. **설계/작성형**: 변수/입력/조건/한 줄 코드 직접 설계

각 축에서 여러 템플릿을 돌려 쓰는 거야.

---

## A. 읽기/이해 중심 템플릿

### A1. 코드 → 자연어 설명 고르기 / 쓰기

**형식**

- 짧은 C 코드 한 덩어리 제시
- 질문: “이 코드는 어떤 일을 하는가?”

  - (1) 보기형(MCQ)
  - (2) 한 줄 서술형(단답형) 둘 다 가능

**예 템플릿**

> [코드]
> 이 프로그램이 하는 일을 가장 잘 설명한 것은?

- A. 두 정수를 입력받아 합을 출력한다.
- B. 한 정수를 입력받아, 음수면 Minus를 출력한다.
- …

**무지성 방지 포인트**

- 보기들을 **전부 유사하게** 만들기 (입력 개수/범위만 살짝 다른 설명)
- 숫자/변수명만 보고 찍기 어렵게, “조건/출력까지 읽어야” 구별되도록

---

### A2. 자연어 → 코드 골라오기

**형식**

- 자연어로 요구사항 설명
- 서로 조금씩 다른 코드 3~4개 제시
- “설명에 딱 맞는 코드를 고르시오”

**예 템플릿**

> - 정수 n 입력
> - n이 0이면 Zero, 양수면 Positive, 음수면 Negative 출력

**코드 A/B/C/D 중 선택**

**무지성 방지 포인트**

- 오답도 **거의 맞지만, 미묘하게 다른** 코드로 구성

  - `>=` vs `>`
  - `&` 빠진 `scanf`
  - else-if 순서 틀리기 등

---

### A3. 실행 추적 / 출력 예측

**형식**

- 완성된 코드 + 입력 예시 하나
- “출력 결과를 줄바꿈까지 포함해 쓰시오”
  or 보기 4개 중 선택(MCQ 버전)

**예 템플릿**

```c
int n;
scanf("%d", &n);
if (n < 0) {
    printf("Minus\n");
}
printf("End\n");
```

입력: `5` → 출력?

**무지성 방지 포인트**

- “줄 순서”, “개행 유무”까지 구분되게 보기 설계
- if 블록 앞/뒤에 printf를 끼워넣어서
  **한 줄만 대충 읽어서는 절대 맞출 수 없게**

---

### A4. 조건식 판단표 (T/F 테이블 채우기)

**형식**

- 조건식 1개 제시: `1 <= n && n <= 5`
- 값 여러 개 제시: `n = 0, 1, 3, 5, 6`
- 테이블 형식으로 “참/거짓” 체크

**예 템플릿**

| n 값 | 조건식 결과 (참/거짓) |
| ---- | --------------------- |
| 0    | ?                     |
| 1    | ?                     |
| 3    | ?                     |
| 5    | ?                     |
| 6    | ?                     |

**무지성 방지 포인트**

- **범위의 양 끝값(1,5)**, 밖의 값(0,6)을 섞어서
  진짜 범위를 이해해야만 표를 정확히 채울 수 있음

---

## B. 판단 / 비교 / 디버깅 템플릿

### B1. 옳은/틀린 코드 판별

**형식**

- 코드 한 덩어리 + 의도 설명
- “이 코드는 설명대로 동작하는가?” → 예/아니오

필요하면:

- “아니오라면, 간단히 이유를 적으시오” (선택형)

**예 템플릿**

> 의도: 음수일 때만 Minus 출력
> [코드]
> 이 코드는 의도대로 동작하는가?

**무지성 방지 포인트**

- “명백한 문법 오류” 말고
  **논리적인 오류**(조건식, 경계값, 잘못된 비교)를 위주로

---

### B2. 버그 위치 찾기 (줄 번호 / 부분 선택)

**형식**

- 5~8줄 정도의 코드
- “의도: ~~. 하지만 한 줄 이상 잘못되어 있다. 잘못된 줄을 모두 고르시오.”

**예 템플릿**

```c
1: int n;
2: scanf("%d", n);
3: if (n < 0);
4: {
5:     printf("Minus\n");
6: }
```

- 잘못된 줄: 2, 3

**무지성 방지 포인트**

- 오답 줄도 “뭔가 이상해 보이긴 하지만 사실은 문제 없는 줄”로 섞기
  → 진짜로 읽어보고 판단해야 함

---

### B3. 반례 찾기 (틀리게 만드는 입력 하나 쓰기)

**형식**

- 의도: “1~10만 InRange 출력”
- 주어진 코드: 미묘하게 틀린 범위/조건
- “이 코드가 틀린 동작을 하도록 만드는 입력 n 값을 하나만 쓰시오.”

**예 템플릿**

```c
if (n > 1 && n < 10) {
    printf("InRange\n");
}
```

의도: 1~10 포함인데, 코드가 그렇게 안 되어 있음.
정답 예: 1, 10 중 아무거나

**무지성 방지 포인트**

- “답이 여러 개”인 구조 → 외운 값만으로는 안 되고
  코드/조건을 이해해야 반례를 찾을 수 있음

---

### B4. 동등/비동등 코드 비교

**형식**

- 코드 A와 코드 B 제시
- “항상 같은 결과를 내는가?” 예/아니오
- or “어떤 입력에서 결과가 달라지는가?” → 반례형으로 확장 가능

**예 템플릿**

코드 A:

```c
if (n >= 1 && n <= 10) printf("In\n");
```

코드 B:

```c
if (!(n < 1 || n > 10)) printf("In\n");
```

**무지성 방지 포인트**

- 단순히 `>=` / `<` 바꿔놓는 수준이 아니라,
  **De Morgan 패턴**처럼 생긴 걸 넣어서 한 번은 진짜 사고하게 만들기

---

## C. 설계 / 작성형 템플릿

### C1. 변수/입력 설계 표 채우기

**형식**

- 자연어 요구사항
- 표: `변수명 / 자료형 / 역할 / 예시 값`
- 학생이 칸을 채우기 (이건 UI에서 input 여러 개)

**예 템플릿**

> 국어, 영어 점수를 입력받아 평균을 출력한다.

| 변수명 | 자료형 | 역할      | 예시 값 |
| ------ | ------ | --------- | ------- |
|        |        | 국어 점수 | 80      |
|        |        | 영어 점수 | 70      |
|        |        | 평균 점수 | 75      |

**무지성 방지 포인트**

- “변수 개수를 최소 몇 개로 할 수 있나?” 같은 추가 서브 질문 가능
- 나중에 이 표를 **코드 작성 문제(C3, C4)와 연계**하면 더 좋아

---

### C2. 조건식/표현식만 작성 (1줄)

**형식**

- if 틀 제공:

  ```c
  if ( /* 여기에 조건식 작성 */ ) {
      printf("InRange\n");
  }
  ```

- “n이 1 이상 10 이하인 경우만 InRange 출력”
  → 괄호 안만 학생이 작성

**무지성 방지 포인트**

- `n > 1 && n < 10` 같은 **경계 틀리기**가 흔한 오답 → 채점 시 구분 가능
- 같은 요구에 대해 **다른 표현**도 허용하고 싶다면
  예: `!(n < 1 || n > 10)`
  → 정답을 여러 패턴으로 등록

---

### C3. I/O 문장만 작성 (scanf/printf 한 줄)

**형식**

- 코드 일부:

```c
int a, b;
// TODO: a와 b에 정수를 입력받는 scanf 한 줄 작성
// TODO: a + b를 출력하는 printf 한 줄 작성
```

**무지성 방지 포인트**

- “변수 이름/타입이 바뀌어도” 같은 템플릿을 써서
  **정말로 형식을 이해했는지** 확인

---

### C4. 코드 블록 배열 (순서 맞추기)

**형식**

- 코드 조각을 섞어서 제공
- “올바른 순서로 나열하시오” or “순서를 번호로 적으시오”

**예 템플릿**

조각:

1. `scanf("%d", &n);`
2. `int n;`
3. `return 0;`
4. `if (n < 0) printf("Minus\n");`

정답: 2 → 1 → 4 → 3

**무지성 방지 포인트**

- “대충 봐도 main 구조 알겠지?”가 아니라
  변수가 선언 전에 쓰이면 안 되는 규칙까지 자연스럽게 학습

---

### C5. 부분 구현: 골격 코드 + TODO

**형식**

- main 전체를 주고, 1~2줄만 TODO

```c
int main(void) {
    int n;
    // TODO: n에 정수를 1개 입력받으시오.

    if (n < 0) {
        printf("Minus\n");
    }

    return 0;
}
```

**무지성 방지 포인트**

- TODO 위치가 언제나 같지 않게:

  - 입력 부분만 비우기도 하고
  - 조건식만 비우기도 하고
  - 출력 포맷만 비우기도 하고

→ “맨날 똑같은 자리 채우기” 패턴으로는 못 풀게.

---

## D. 연계(시퀀스) 템플릿 예시

각 연습장(예: if-basic) 안에서는 위 템플릿을 **세트로 묶어서** 쓰면 좋아.

### 예: if-basic 연습장 시퀀스

1. **A1 (코드 → 설명)**

   - if가 대략 무슨 일을 하는지 이해

2. **A3 (실행 추적)**

   - 입력 2~3개에 대해 출력 맞추기

3. **B3 (반례 찾기)**

   - “이 코드가 틀리게 동작하는 입력 한 개 쓰기”

4. **C2 (조건식 한 줄 작성)**

   - 이제 스스로 같은 기능을 하는 조건식을 직접 써보기

이 흐름이면:

- **읽기 → 예상 → 판별/비판 → 직접 작성**까지 한 사이클이라
  애들이 무지성으로 찍고 넘어가기 어렵고,
- 그래도 한 사이클이 4문제라 부담도 크지 않음.

---

## E. 무지성 방지 공통 팁

각 템플릿에 공통으로 적용하면 좋은 옵션들:

1. **숫자/범위 랜덤화**

   - 같은 템플릿이라도 학생마다 `1~10` 대신 `10~20`이 나올 수 있게
   - “외운 답”이 통하지 않도록

2. **오답을 “전형적인 실수 패턴”으로 만들기**

   - `>=` vs `>`
   - `&n` 빠진 scanf
   - `if (cond);` 같은 것들

3. **연계형으로 묶기**

   - 앞 문제의 이해가 뒤 문제에서 그대로 쓰이게
   - 예: A3에서 본 코드가 B3, C2에서 계속 등장

4. **너무 많은 보기/과한 길이는 피하기**

   - 약한 학생에게는 “짧지만 꼭 생각해야 하는 문제” 여러 개가 더 좋음

---

# 스키마

좋아, 이제 진짜 “연습장 설계자 모드”로 한 번 정리해보자 😎

목표를 다시 한 줄로 말하면:

> **AP CS 같은 ‘코드 읽고 생각하는 힘’을 기르되,
> 지금 애들 수준(하나 알려줘도 하나 못함)에 맞게 난이도만 내린 템플릿 세트.**
> 그리고 **무지성 패턴 암기로는 못 푸는 문제들.**

그래서 **연습장에 쓸 문제 유형**을 “템플릿”처럼 정리할게.
각 템플릿은:

- 학생이 보는 형식
- 답 형태
- 무지성 방지 포인트

까지 같이 적을게.

---

## 0. 전체 큰 분류

연습장 문제를 크게 3축으로 나누면 좋아:

1. **읽기/이해형**: 코드를 읽고 의미 파악, 출력 예측
2. **판단/비교/디버깅형**: 옳고 그름 판단, 버그 찾기, 반례 찾기
3. **설계/작성형**: 변수/입력/조건/한 줄 코드 직접 설계

각 축에서 여러 템플릿을 돌려 쓰는 거야.

---

## A. 읽기/이해 중심 템플릿

### A1. 코드 → 자연어 설명 고르기 / 쓰기

**형식**

- 짧은 C 코드 한 덩어리 제시
- 질문: “이 코드는 어떤 일을 하는가?”

  - (1) 보기형(MCQ)
  - (2) 한 줄 서술형(단답형) 둘 다 가능

**예 템플릿**

> [코드]
> 이 프로그램이 하는 일을 가장 잘 설명한 것은?

- A. 두 정수를 입력받아 합을 출력한다.
- B. 한 정수를 입력받아, 음수면 Minus를 출력한다.
- …

**무지성 방지 포인트**

- 보기들을 **전부 유사하게** 만들기 (입력 개수/범위만 살짝 다른 설명)
- 숫자/변수명만 보고 찍기 어렵게, “조건/출력까지 읽어야” 구별되도록

---

### A2. 자연어 → 코드 골라오기

**형식**

- 자연어로 요구사항 설명
- 서로 조금씩 다른 코드 3~4개 제시
- “설명에 딱 맞는 코드를 고르시오”

**예 템플릿**

> - 정수 n 입력
> - n이 0이면 Zero, 양수면 Positive, 음수면 Negative 출력

**코드 A/B/C/D 중 선택**

**무지성 방지 포인트**

- 오답도 **거의 맞지만, 미묘하게 다른** 코드로 구성

  - `>=` vs `>`
  - `&` 빠진 `scanf`
  - else-if 순서 틀리기 등

---

### A3. 실행 추적 / 출력 예측

**형식**

- 완성된 코드 + 입력 예시 하나
- “출력 결과를 줄바꿈까지 포함해 쓰시오”
  or 보기 4개 중 선택(MCQ 버전)

**예 템플릿**

```c
int n;
scanf("%d", &n);
if (n < 0) {
    printf("Minus\n");
}
printf("End\n");
```

입력: `5` → 출력?

**무지성 방지 포인트**

- “줄 순서”, “개행 유무”까지 구분되게 보기 설계
- if 블록 앞/뒤에 printf를 끼워넣어서
  **한 줄만 대충 읽어서는 절대 맞출 수 없게**

---

### A4. 조건식 판단표 (T/F 테이블 채우기)

**형식**

- 조건식 1개 제시: `1 <= n && n <= 5`
- 값 여러 개 제시: `n = 0, 1, 3, 5, 6`
- 테이블 형식으로 “참/거짓” 체크

**예 템플릿**

| n 값 | 조건식 결과 (참/거짓) |
| ---- | --------------------- |
| 0    | ?                     |
| 1    | ?                     |
| 3    | ?                     |
| 5    | ?                     |
| 6    | ?                     |

**무지성 방지 포인트**

- **범위의 양 끝값(1,5)**, 밖의 값(0,6)을 섞어서
  진짜 범위를 이해해야만 표를 정확히 채울 수 있음

---

## B. 판단 / 비교 / 디버깅 템플릿

### B1. 옳은/틀린 코드 판별

**형식**

- 코드 한 덩어리 + 의도 설명
- “이 코드는 설명대로 동작하는가?” → 예/아니오

필요하면:

- “아니오라면, 간단히 이유를 적으시오” (선택형)

**예 템플릿**

> 의도: 음수일 때만 Minus 출력
> [코드]
> 이 코드는 의도대로 동작하는가?

**무지성 방지 포인트**

- “명백한 문법 오류” 말고
  **논리적인 오류**(조건식, 경계값, 잘못된 비교)를 위주로

---

### B2. 버그 위치 찾기 (줄 번호 / 부분 선택)

**형식**

- 5~8줄 정도의 코드
- “의도: ~~. 하지만 한 줄 이상 잘못되어 있다. 잘못된 줄을 모두 고르시오.”

**예 템플릿**

```c
1: int n;
2: scanf("%d", n);
3: if (n < 0);
4: {
5:     printf("Minus\n");
6: }
```

- 잘못된 줄: 2, 3

**무지성 방지 포인트**

- 오답 줄도 “뭔가 이상해 보이긴 하지만 사실은 문제 없는 줄”로 섞기
  → 진짜로 읽어보고 판단해야 함

---

### B3. 반례 찾기 (틀리게 만드는 입력 하나 쓰기)

**형식**

- 의도: “1~10만 InRange 출력”
- 주어진 코드: 미묘하게 틀린 범위/조건
- “이 코드가 틀린 동작을 하도록 만드는 입력 n 값을 하나만 쓰시오.”

**예 템플릿**

```c
if (n > 1 && n < 10) {
    printf("InRange\n");
}
```

의도: 1~10 포함인데, 코드가 그렇게 안 되어 있음.
정답 예: 1, 10 중 아무거나

**무지성 방지 포인트**

- “답이 여러 개”인 구조 → 외운 값만으로는 안 되고
  코드/조건을 이해해야 반례를 찾을 수 있음

---

### B4. 동등/비동등 코드 비교

**형식**

- 코드 A와 코드 B 제시
- “항상 같은 결과를 내는가?” 예/아니오
- or “어떤 입력에서 결과가 달라지는가?” → 반례형으로 확장 가능

**예 템플릿**

코드 A:

```c
if (n >= 1 && n <= 10) printf("In\n");
```

코드 B:

```c
if (!(n < 1 || n > 10)) printf("In\n");
```

**무지성 방지 포인트**

- 단순히 `>=` / `<` 바꿔놓는 수준이 아니라,
  **De Morgan 패턴**처럼 생긴 걸 넣어서 한 번은 진짜 사고하게 만들기

---

## C. 설계 / 작성형 템플릿

### C1. 변수/입력 설계 표 채우기

**형식**

- 자연어 요구사항
- 표: `변수명 / 자료형 / 역할 / 예시 값`
- 학생이 칸을 채우기 (이건 UI에서 input 여러 개)

**예 템플릿**

> 국어, 영어 점수를 입력받아 평균을 출력한다.

| 변수명 | 자료형 | 역할      | 예시 값 |
| ------ | ------ | --------- | ------- |
|        |        | 국어 점수 | 80      |
|        |        | 영어 점수 | 70      |
|        |        | 평균 점수 | 75      |

**무지성 방지 포인트**

- “변수 개수를 최소 몇 개로 할 수 있나?” 같은 추가 서브 질문 가능
- 나중에 이 표를 **코드 작성 문제(C3, C4)와 연계**하면 더 좋아

---

### C2. 조건식/표현식만 작성 (1줄)

**형식**

- if 틀 제공:

  ```c
  if ( /* 여기에 조건식 작성 */ ) {
      printf("InRange\n");
  }
  ```

- “n이 1 이상 10 이하인 경우만 InRange 출력”
  → 괄호 안만 학생이 작성

**무지성 방지 포인트**

- `n > 1 && n < 10` 같은 **경계 틀리기**가 흔한 오답 → 채점 시 구분 가능
- 같은 요구에 대해 **다른 표현**도 허용하고 싶다면
  예: `!(n < 1 || n > 10)`
  → 정답을 여러 패턴으로 등록

---

### C3. I/O 문장만 작성 (scanf/printf 한 줄)

**형식**

- 코드 일부:

```c
int a, b;
// TODO: a와 b에 정수를 입력받는 scanf 한 줄 작성
// TODO: a + b를 출력하는 printf 한 줄 작성
```

**무지성 방지 포인트**

- “변수 이름/타입이 바뀌어도” 같은 템플릿을 써서
  **정말로 형식을 이해했는지** 확인

---

### C4. 코드 블록 배열 (순서 맞추기)

**형식**

- 코드 조각을 섞어서 제공
- “올바른 순서로 나열하시오” or “순서를 번호로 적으시오”

**예 템플릿**

조각:

1. `scanf("%d", &n);`
2. `int n;`
3. `return 0;`
4. `if (n < 0) printf("Minus\n");`

정답: 2 → 1 → 4 → 3

**무지성 방지 포인트**

- “대충 봐도 main 구조 알겠지?”가 아니라
  변수가 선언 전에 쓰이면 안 되는 규칙까지 자연스럽게 학습

---

### C5. 부분 구현: 골격 코드 + TODO

**형식**

- main 전체를 주고, 1~2줄만 TODO

```c
int main(void) {
    int n;
    // TODO: n에 정수를 1개 입력받으시오.

    if (n < 0) {
        printf("Minus\n");
    }

    return 0;
}
```

**무지성 방지 포인트**

- TODO 위치가 언제나 같지 않게:

  - 입력 부분만 비우기도 하고
  - 조건식만 비우기도 하고
  - 출력 포맷만 비우기도 하고

→ “맨날 똑같은 자리 채우기” 패턴으로는 못 풀게.

---

## D. 연계(시퀀스) 템플릿 예시

각 연습장(예: if-basic) 안에서는 위 템플릿을 **세트로 묶어서** 쓰면 좋아.

### 예: if-basic 연습장 시퀀스

1. **A1 (코드 → 설명)**

   - if가 대략 무슨 일을 하는지 이해

2. **A3 (실행 추적)**

   - 입력 2~3개에 대해 출력 맞추기

3. **B3 (반례 찾기)**

   - “이 코드가 틀리게 동작하는 입력 한 개 쓰기”

4. **C2 (조건식 한 줄 작성)**

   - 이제 스스로 같은 기능을 하는 조건식을 직접 써보기

이 흐름이면:

- **읽기 → 예상 → 판별/비판 → 직접 작성**까지 한 사이클이라
  애들이 무지성으로 찍고 넘어가기 어렵고,
- 그래도 한 사이클이 4문제라 부담도 크지 않음.

---

## E. 무지성 방지 공통 팁

각 템플릿에 공통으로 적용하면 좋은 옵션들:

1. **숫자/범위 랜덤화**

   - 같은 템플릿이라도 학생마다 `1~10` 대신 `10~20`이 나올 수 있게
   - “외운 답”이 통하지 않도록

2. **오답을 “전형적인 실수 패턴”으로 만들기**

   - `>=` vs `>`
   - `&n` 빠진 scanf
   - `if (cond);` 같은 것들

3. **연계형으로 묶기**

   - 앞 문제의 이해가 뒤 문제에서 그대로 쓰이게
   - 예: A3에서 본 코드가 B3, C2에서 계속 등장

4. **너무 많은 보기/과한 길이는 피하기**

   - 약한 학생에게는 “짧지만 꼭 생각해야 하는 문제” 여러 개가 더 좋음

---

이 정도 템플릿 세트면:

- if뿐 아니라

  - 연산자,
  - 반복문,
  - 배열
    로 그대로 확장 가능하고,

- 나중에 DB에 `type`, `subtype` 정도만 박아두고
  랜덤 파라미터만 채워 넣어도 **문제은행처럼 돌릴 수 있는 구조**가 나와.

원하면,
이 템플릿 목록을 그대로 쓸 수 있게 **간단한 JSON 스키마**(예: `kind: "A3", params: {...}`)로도 한 번 정리해줄게.

---

# 스키마

좋아, 이제 진짜 “기계가 돌릴 수 있는 템플릿”으로 정리해볼게.
말 그대로 이런 느낌:

```json
{ "kind": "A3_EXEC_TRACE", "params": { ... } }
```

---

## 1. 연습장(Lab) 전체 JSON 구조

```jsonc
{
  "labId": "if-basic-1",
  "title": "조건문 연습장 기초",
  "description": "if, 비교, 논리 연산 연습용 문제 세트",
  "questions": [
    {
      "id": "q1",
      "kind": "A1_CODE_TO_DESC",
      "meta": {
        "difficulty": "easy",
        "tags": ["if", "입출력"]
      },
      "params": {
        /* 템플릿별 필드 */
      }
    }
  ]
}
```

- `labId`, `title`, `description`: 연습장 단위 식별/표시용
- `questions[]` 안에 **각 템플릿 인스턴스**가 들어감
- `kind`: 템플릿 종류 (A1, B3, C2 …)
- `meta`: 난이도, 태그 등 선택사항
- `params`: **각 kind별로 달라지는 부분** (문제 내용/정답)

---

## 2. 템플릿별 `kind` + `params` 스키마

### A. 읽기/이해 템플릿

#### A1. 코드 → 자연어 설명 (CODE_TO_DESC)

```jsonc
{
  "kind": "A1_CODE_TO_DESC",
  "params": {
    "stem": "이 프로그램이 하는 일을 가장 잘 설명한 것을 고르시오.",
    "code": "int n; scanf(\"%d\", &n); if (n < 0) printf(\"Minus\\n\");",
    "options": [
      "정수 1개를 입력받아 그대로 출력한다.",
      "정수 1개를 입력받아, 음수이면 Minus를 출력한다.",
      "두 정수를 입력받아 합을 출력한다.",
      "정수 1개를 입력받아, 0이면 Zero를 출력한다."
    ],
    "correctIndex": 1
  }
}
```

---

#### A2. 자연어 → 코드 선택 (DESC_TO_CODE)

```jsonc
{
  "kind": "A2_DESC_TO_CODE",
  "params": {
    "stem": "- 정수 n을 입력받는다.\n- n이 0이면 Zero, 양수면 Positive, 음수면 Negative를 출력한다.",
    "options": [
      "int n; scanf(\"%d\", &n); if (n > 0) printf(\"Positive\\n\"); else if (n == 0) printf(\"Zero\\n\"); else printf(\"Negative\\n\");",
      "int n; scanf(\"%d\", &n); if (n >= 0) printf(\"Positive\\n\"); else printf(\"Negative\\n\");",
      "... 생략 ..."
    ],
    "correctIndex": 0
  }
}
```

---

#### A3. 실행 추적 (EXEC_TRACE)

```jsonc
{
  "kind": "A3_EXEC_TRACE",
  "params": {
    "stem": "아래 프로그램에서 입력이 -3일 때, 출력 결과를 줄바꿈까지 포함해 쓰시오.",
    "code": "int n; scanf(\"%d\", &n); printf(\"%d\\n\", n); if (n < 0) printf(\"Minus\\n\");",
    "input": "-3",
    "expectedOutputLines": ["-3", "Minus"] // 줄 단위
  }
}
```

---

#### A4. 조건식 진리표 (COND_TRUTH_TABLE)

```jsonc
{
  "kind": "A4_COND_TRUTH_TABLE",
  "params": {
    "stem": "조건식 (1 <= n && n <= 5)가 참이 되는 n을 표시하시오.",
    "condition": "1 <= n && n <= 5",
    "values": [0, 1, 3, 5, 6],
    "truth": [false, true, true, true, false]
  }
}
```

---

### B. 판단 / 디버깅 템플릿

#### B1. 옳은/틀린 코드 판별 (CORRECTNESS_JUDGE)

```jsonc
{
  "kind": "B1_CORRECTNESS_JUDGE",
  "params": {
    "intent": "음수일 때만 Minus를 출력하려고 한다.",
    "code": "int n; scanf(\"%d\", &n); if (n < 0) printf(\"Minus\\n\");",
    "isCorrect": true,
    "explanation": "0이나 양수일 때는 아무 것도 출력하지 않으므로 의도대로 동작한다."
  }
}
```

---

#### B2. 버그 위치 찾기 (BUG_LOCATE)

```jsonc
{
  "kind": "B2_BUG_LOCATE",
  "params": {
    "stem": "아래 코드에서 잘못된 줄 번호를 모두 고르시오.",
    "lines": [
      "1: int n;",
      "2: scanf(\"%d\", n);",
      "3: if (n < 0);",
      "4: {",
      "5:     printf(\"Minus\\n\");",
      "6: }"
    ],
    "wrongLineNumbers": [2, 3]
  }
}
```

---

#### B3. 반례 찾기 (FIND_COUNTEREXAMPLE)

```jsonc
{
  "kind": "B3_FIND_COUNTEREXAMPLE",
  "params": {
    "stem": "아래 코드가 의도(1~10 포함)와 다르게 동작하도록 만드는 n 값을 하나 쓰시오.",
    "intent": "1 이상 10 이하이면 InRange 출력",
    "code": "if (n > 1 && n < 10) printf(\"InRange\\n\");",
    "domainHint": "예: -100 ~ 100 범위의 정수",
    "sampleCorrectAnswers": ["1", "10"] // 여러 개 중 아무거나 맞으면 정답
  }
}
```

---

#### B4. 동등/비동등 코드 비교 (EQUIVALENCE)

```jsonc
{
  "kind": "B4_EQUIVALENCE",
  "params": {
    "stem": "코드 A와 B는 항상 같은 결과를 내는가?",
    "codeA": "if (n >= 1 && n <= 10) printf(\"In\\n\");",
    "codeB": "if (!(n < 1 || n > 10)) printf(\"In\\n\");",
    "areEquivalent": true,
    "exampleDiffInputs": [] // 비동등일 때는 여기 반례 예시를 넣어도 됨
  }
}
```

---

### C. 설계 / 작성 템플릿

#### C1. 변수/입력 설계 표 (VAR_TABLE)

```jsonc
{
  "kind": "C1_VAR_TABLE",
  "params": {
    "stem": "국어, 영어 점수를 입력받아 평균을 출력하는 프로그램을 위한 변수들을 채우시오.",
    "rows": [
      {
        "role": "국어 점수",
        "expectedName": "kor",
        "expectedType": "int",
        "exampleValue": 80
      },
      {
        "role": "영어 점수",
        "expectedName": "eng",
        "expectedType": "int",
        "exampleValue": 70
      },
      {
        "role": "평균 점수(정수 나눗셈)",
        "expectedName": "avg",
        "expectedType": "int",
        "exampleValue": 75
      }
    ]
  }
}
```

---

#### C2. 조건식만 작성 (COND_ONLY)

```jsonc
{
  "kind": "C2_COND_ONLY",
  "params": {
    "stem": "n이 1 이상 10 이하인 경우만 if 안이 실행되도록 조건식을 작성하시오.",
    "contextBefore": "if ( ",
    "contextAfter": " ) {\n    printf(\"InRange\\n\");\n}",
    "acceptedExpressions": [
      "n >= 1 && n <= 10",
      "1 <= n && n <= 10",
      "!(n < 1 || n > 10)"
    ]
  }
}
```

---

#### C3. 입출력 문장 작성 (IO_STATEMENT)

```jsonc
{
  "kind": "C3_IO_STATEMENT",
  "params": {
    "stem": "정수 변수 a, b에 값을 입력받는 scanf 한 줄을 작성하시오.",
    "contextCode": "int a, b;\n// 여기에 scanf 한 줄을 작성하시오.",
    "expectedCode": "scanf(\"%d %d\", &a, &b);",
    "acceptedVariants": ["scanf(\"%d%d\", &a, &b);"]
  }
}
```

---

#### C4. 코드 블록 순서 맞추기 (BLOCK_ORDER)

```jsonc
{
  "kind": "C4_BLOCK_ORDER",
  "params": {
    "stem": "올바른 순서로 코드를 나열했을 때, 순서를 번호로 쓰시오.",
    "blocks": [
      "int n;",
      "scanf(\"%d\", &n);",
      "if (n < 0) printf(\"Minus\\n\");",
      "return 0;"
    ],
    "correctOrder": [0, 1, 2, 3] // index 순서
  }
}
```

---

#### C5. 부분 구현 (PARTIAL_IMPLEMENTATION)

```jsonc
{
  "kind": "C5_PARTIAL_IMPLEMENTATION",
  "params": {
    "stem": "TODO 부분을 채워 음수이면 Minus를 출력하도록 완성하시오.",
    "codeTemplate": "int main(void) {\n    int n;\n    /*INPUT*/\n    if (/*COND*/) {\n        printf(\"Minus\\n\");\n    }\n    return 0;\n}",
    "placeholders": [
      {
        "name": "INPUT",
        "expectedCode": "scanf(\"%d\", &n);"
      },
      {
        "name": "COND",
        "expectedCode": "n < 0"
      }
    ]
  }
}
```

---

## 3. 최소 세트 예시 (if-basic 연습장)

마지막으로, 진짜로 돌아갈 수 있는 “작은 if 연습장” 예시는 이렇게 묶을 수 있어요:

```jsonc
{
  "labId": "if-basic-1",
  "title": "조건문 연습장 기초",
  "description": "if, 비교, 논리 연산 기본 연습",
  "questions": [
    {
      "id": "q1",
      "kind": "A1_CODE_TO_DESC",
      "meta": { "difficulty": "easy", "tags": ["if", "이해"] },
      "params": { ... A1 예시 ... }
    },
    {
      "id": "q2",
      "kind": "A3_EXEC_TRACE",
      "meta": { "difficulty": "easy", "tags": ["if", "실행추적"] },
      "params": { ... A3 예시 ... }
    },
    {
      "id": "q3",
      "kind": "B3_FIND_COUNTEREXAMPLE",
      "meta": { "difficulty": "medium", "tags": ["if", "반례"] },
      "params": { ... B3 예시 ... }
    },
    {
      "id": "q4",
      "kind": "C2_COND_ONLY",
      "meta": { "difficulty": "medium", "tags": ["if", "조건식작성"] },
      "params": { ... C2 예시 ... }
    }
  ]
}
```

이 스키마 하나 정해두면:

- 프런트에서는 `kind` 보고 렌더러만 스위치
- 서버/DB에서는 `labId` 단위로 JSON만 저장
- 새 문제 추가 = `questions`에 JSON 하나 더 push

하는 식으로 **연습장 템플릿 양산**이 가능해질 거야.
