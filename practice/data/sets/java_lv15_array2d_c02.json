{
  "id": "java_array2d_lv15_c02",
  "title": "Java 2차원 배열 LV15 챌린지 2회차",
  "categoryId": "java_array2d",
  "availableLanguages": [
    "java"
  ],
  "problems": [
    {
      "id": "mcq1",
      "type": "mcq",
      "level": "챌린지",
      "title": "MCQ 1. 행 교환의 의미",
      "description": "다음 코드 실행 후, `a[0][0]`의 값은 무엇이 될까요?\n\n```java\nint[][] a = {\n    {1, 2},\n    {3, 4},\n    {5, 6}\n};\nint r1 = 0, r2 = 2;\nint[] tmp = a[r1];\na[r1] = a[r2];\na[r2] = tmp;\nSystem.out.println(a[0][0]);\n```\n",
      "code": null,
      "options": [
        "1",
        "3",
        "5",
        "컴파일 에러"
      ],
      "optionLabels": [
        "A",
        "B",
        "C",
        "D"
      ],
      "correctIndex": 2
    },
    {
      "id": "mcq2",
      "type": "mcq",
      "level": "챌린지",
      "title": "MCQ 2. 전치(in-place)에서 반복문 범위",
      "description": "정사각형 배열 `a`를 **in-place 전치(transpose)** 하려고 합니다.\n중복 스왑을 피하려면 안쪽 반복문 `j`의 시작값으로 가장 적절한 것은?\n\n```java\nfor (int i = 0; i < n; i++) {\n    for (int j = ?; j < n; j++) {\n        int tmp = a[i][j];\n        a[i][j] = a[j][i];\n        a[j][i] = tmp;\n    }\n}\n```\n",
      "code": null,
      "options": [
        "0",
        "1",
        "i",
        "i + 1"
      ],
      "optionLabels": [
        "A",
        "B",
        "C",
        "D"
      ],
      "correctIndex": 3
    },
    {
      "id": "mcq3",
      "type": "mcq",
      "level": "챌린지",
      "title": "MCQ 3. 90도 회전(새 배열) 인덱싱",
      "description": "`n×n` 정사각형 배열 `a`를 시계 방향으로 90도 회전한 결과를 `b`에 저장하려고 합니다.\n다음 중 올바른 대입식은?\n\n(0-indexed, `0 <= i, j < n`)\n",
      "code": null,
      "options": [
        "b[i][j] = a[i][j];",
        "b[j][n - 1 - i] = a[i][j];",
        "b[n - 1 - i][n - 1 - j] = a[i][j];",
        "b[n - 1 - j][i] = a[i][j];"
      ],
      "optionLabels": [
        "A",
        "B",
        "C",
        "D"
      ],
      "correctIndex": 1
    },
    {
      "id": "short1",
      "type": "short",
      "level": "단답형",
      "title": "Short 1. 행 swap 후 원소",
      "description": "아래 코드가 출력하는 숫자를 쓰세요. (한 줄, 숫자만)",
      "code": "int[][] a = {\n    {1, 2, 3},\n    {4, 5, 6}\n};\nint[] tmp = a[0];\na[0] = a[1];\na[1] = tmp;\nSystem.out.println(a[0][2]);",
      "expectedText": "6"
    },
    {
      "id": "short2",
      "type": "short",
      "level": "단답형",
      "title": "Short 2. 전치 후 출력",
      "description": "아래 코드가 출력하는 내용을 그대로 쓰세요. (공백 포함, 한 줄입니다.)",
      "code": "int[][] a = {\n    {1, 2, 3},\n    {4, 5, 6},\n    {7, 8, 9}\n};\nint n = a.length;\nfor (int i = 0; i < n; i++) {\n    for (int j = i + 1; j < n; j++) {\n        int tmp = a[i][j];\n        a[i][j] = a[j][i];\n        a[j][i] = tmp;\n    }\n}\nSystem.out.println(a[0][1] + \" \" + a[1][0]);",
      "expectedText": "4 2"
    },
    {
      "id": "code1",
      "type": "code",
      "level": "코드 작성",
      "title": "Code 1. 행 교환(3줄)",
      "description": "아래 코드에서 주석 위치에 들어갈 코드를 작성하세요.\n`r1`행과 `r2`행을 **서로 교환(swap)** 해야 합니다. (3줄이면 충분합니다.)",
      "code": "int[][] a = {\n    {1, 2, 3},\n    {4, 5, 6},\n    {7, 8, 9}\n};\nint r1 = 0, r2 = 2;\n\n// TODO: r1행과 r2행을 교환\n\nSystem.out.println(a[0][0] + \" \" + a[2][0]);",
      "expectedCode": "int[] tmp = a[r1];\na[r1] = a[r2];\na[r2] = tmp;",
      "hint": "2차원 배열의 각 행은 `int[]` 참조입니다. 행 교환은 참조 교환으로 끝납니다."
    },
    {
      "id": "code2",
      "type": "code",
      "level": "코드 작성",
      "title": "Code 2. in-place 전치의 안쪽 for문(한 줄)",
      "description": "정사각형 배열 `a`를 in-place로 전치하려고 합니다.\n주석이 있는 **안쪽 for문 한 줄**을 수정해서, (i,j)와 (j,i)를 **한 번만** swap 하도록 만드세요.",
      "code": "int[][] a = {\n    {1, 2, 3},\n    {4, 5, 6},\n    {7, 8, 9}\n};\nint n = a.length;\n\nfor (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) { // TODO: 이 한 줄을 중복 스왑이 없도록 수정\n        int tmp = a[i][j];\n        a[i][j] = a[j][i];\n        a[j][i] = tmp;\n    }\n}\nSystem.out.println(a[0][1]);",
      "expectedCode": "for (int j = i + 1; j < n; j++) {",
      "hint": "전치는 대각선 위쪽(또는 아래쪽)만 스왑하면 됩니다."
    },
    {
      "id": "code3",
      "type": "code",
      "level": "코드 작성",
      "title": "Code 3. 90도 회전(새 배열) 대입식(한 줄)",
      "description": "`n×n` 배열 `a`를 **시계 방향 90도 회전**한 결과를 `b`에 저장하려고 합니다.\n아래 코드의 주석 위치에 들어갈 **대입 한 줄**을 작성하세요.",
      "code": "int[][] a = {\n    {1, 2, 3},\n    {4, 5, 6},\n    {7, 8, 9}\n};\nint n = a.length;\nint[][] b = new int[n][n];\n\nfor (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n        // TODO: 회전 결과 대입 한 줄\n    }\n}\nSystem.out.println(b[0][0] + \" \" + b[0][1] + \" \" + b[0][2]);",
      "expectedCode": "b[j][n - 1 - i] = a[i][j];",
      "hint": "원래의 (i,j)가 회전 후 어디로 가는지 작은 예(3×3)로 찍어보면 매핑이 보입니다."
    },
    {
      "id": "code4",
      "type": "code",
      "level": "코드 작성",
      "title": "Code 4. 행 단위 오른쪽 쉬프트(한 줄)",
      "description": "아래는 각 행을 **오른쪽으로 한 칸씩 회전(shift)** 한 새 배열 `b`를 만드는 코드입니다.\n주석 위치에 들어갈 **대입 한 줄**을 작성하세요.\n\n예: `[1,2,3]` → `[3,1,2]`",
      "code": "int[][] a = {\n    {1, 2, 3},\n    {4, 5, 6}\n};\nint R = a.length;\nint C = a[0].length;\nint[][] b = new int[R][C];\n\nfor (int i = 0; i < R; i++) {\n    for (int j = 0; j < C; j++) {\n        // TODO: 오른쪽으로 한 칸 이동한 위치에 저장\n    }\n}\nSystem.out.println(b[0][0] + \" \" + b[0][1] + \" \" + b[0][2]);",
      "expectedCode": "b[i][(j + 1) % C] = a[i][j];",
      "hint": "오른쪽으로 1칸이면 새 열 인덱스가 `j+1`이고, 마지막 열은 0으로 돌아옵니다."
    }
  ]
}